#!/usr/bin/env python
"""Module for combinatorial generation and permutations"""
from math import *
from fractions import gcd

__author__ = "rmanders"
__status__ = "Development"

# =============================================================================
def all_permutations(S):
	""" Generates all permutations of elements in the list"""
	if len(S) <=1:
		yield S
	else:
		for perm in all_permutations(S[1:]):
			for i in range(len(perm)+1):
				yield perm[:i] + S[0:1] + perm[i:]

# =============================================================================			
def k_combinations(S, k):
	if k==0: yield []
	else:
		for i in xrange(len(S)):
			for comb in k_combinations(S[i+1:],k-1):
				yield comb + [S[i]]

				
# part(n,g) = the number of partitions on n objects where the smallest 
#             partition is of size g.
# part(1,1) = 1
# part(n,g) = part(n-g,g) + part(n-g,g+1) + ... + part(n-g,n-g)

def part( n, g ):
	if( n == 1):
		return 1
	elif( n == g ):
		return 1
	elif( g > n or g <= 0):
		return 0
	else:
		sum=0
		for i in range(g,n-g+1,1):
			sum += part(n-g,i)
		return sum

def numPartitions( n ):
	sum = 0
	for i in range(1,n+1,1):
		sum += part(n, i)
	return sum
	
	
# =============================================================================
# genPartitions Version (1)
# =============================================================================
# Non-recursive generator of all paritions on n indistinguishable objects. 
# The next set of paritions (state) generated is based only on the previous 
# state generated, so only the previous state needs to be maintained. 
#
# [Initial and Final Conditions]:
# We initialize the generator by starting with n partitions of size 1 
# and terminate when we reach one partition of size n. 
#
# [Data structures]
# Each way to partition (state) is represented as a list of integers. These 
# integers are the size of the partitions and always sum to n. The next 
# "state" is generated by examinig this list and determining how many of each 
# size partition there is. 
#
# [Algorithm]
# Each new state can be generated uniquely by modifying the current state 
# in the following way:
# [A] If there are 2 or more paritions of size 1, then merge any 2 paritions
#     of size 1 into a single parition of size 2.   
#
# [B] If there are less than 2 paritions of size 1, then we need to create 
#     another partition of the next largest size other than 2. To do this,
#     we accumulate a sum starting at all objects in partitions of size 1, 
#     then sum over all objects in partitions of size 2, etc until the total
#     sum is greater than or equal to the size of partition we are currently
# 	  trying to sum over. In other words, if our sum (count of objects ) 
#     is >= a partition of size i, where 1 <= i <= n, then we now enough objects
#     to make a new parition of size i. Now if the sum is greater than i
#     (which means there will be extra objects left over after we put i objects
#     of the sum into a new i-partition) we make new paritions of size 1 from 
#     from the remaining objects, then continue. In this way we will eventually
#     always create a new partition of size n and zero other partitions
#     (which is our terminating condition).
# =============================================================================
def genPartitions( n ):
	lastPart = [1]*n
	yield lastPart
	
	while( lastPart.count(n) < 1 ):
		if( lastPart.count(1) - 2 >= 0 ):
			# number of 1's
			l = [1] * (lastPart.count(1)-2)
			
			#number of 2's
			l += [2] * (lastPart.count(2)+1)
			
			#handle the rest of the paritions
			for k in range( 3, n, 1 ):
				l += [k] * (lastPart.count(k))
			lastPart = l
			yield lastPart			
		else:
			total  = lastPart.count(1)
			x = 2
			while( total < x and x < n):
				total += lastPart.count(x)*x
				x +=1
			l = [x] * (lastPart.count(x) + 1)
			total -= x
			l += [1]*total
			for y in range( x+1, n, 1 ):
				l += [y] * (lastPart.count(y))
			lastPart = l
			yield lastPart	
			
def printIntPart( n ):
	for i in genPartitions( n ):
		i.sort()
		print(i)
		
# Calculates the total number of isomorphism classes in the 
# set of graphs of n vertices. Uses the partition generator
# and Cycle Index polynomial Z.
def numIsomorphismClasses( n ):
	f = factorial( n )
	terms = 0
	
	#for each way to partition n objects, generate a monomial of Z	
	for p in genPartitions( n ):
		coef = 1
		monomial = 1
		for i in range( 1, n+1, 1 ):
			c = p.count(i)
			if( c > 0 ):
				coef *= int((factorial(c)*(pow(i,c))))
				monomial *= int(pow(n,c))
		terms += coef*monomial
	
	return int(terms/f)
			
		
# ==== TEST CODE ====

#n = 5
#f = factorial( n )
#s = "(1/" + str(f) + ") ("
#for p in genPartitions( n ):
#	
#	term = ""
#	div=1
#	for i in range( 1, n+1, 1 ):
#		c = p.count(i)						
#		if( c > 0 ):
#			div *=(factorial(c)*(pow(i,c)))
#			term += "s(" + str(i) + ")^" + str(c)
#		
#	s += str(int(f/div)) + term + " + "
#s += ")"
#print s
	



